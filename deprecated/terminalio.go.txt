/*
Handles interaction with the command line.
*/
// package terminalio

// var (
// 	DEBUG bool = true
// )

// type termCommand struct {
// 	command string
// }

// type commandReturn string

// /* Git commands. */
// var (
// 	gitStatus     = termCommand{command: "git status"}
// 	gitAddAll     = termCommand{command: "git add ."}
// 	gitCommit     = termCommand{command: "git commit -am 'Commit made from dotf-go'"}
// 	gitPullMerge  = termCommand{command: "git merge origin/master -m 'Merge made by dotf-go'"}
// 	gitAbortMerge = termCommand{command: "git merge --abort"}
// 	gitPush       = termCommand{command: "git push origin master"}
// )

// /* Status returned by git.
// Case sensitive substring contained in the returns from running commands with git version 2.32.0 */
// const (
// 	allUpToDate             commandReturn = "Already up to date."
// 	nothingToCommit         commandReturn = "nothing to commit, working tree clean"
// 	changesToCommit         commandReturn = "Changes to be committed"
// 	untrackedFiles          commandReturn = "Untracked files"
// 	localBranchBehindRemote commandReturn = "Your branch is behind"
// 	canBeFastForwarded      commandReturn = "and can be fast-forwarded"
// 	mergeWasSuccessful      commandReturn = "Merge made by"
// 	pushWasSuccessful       commandReturn = "master -> master" // Something is making git push return only last line.
// 	branchAheadOfRemote     commandReturn = "Your branch is ahead of"
// )

// /* SyncLocalAndRemote will update both local repository and remote with newest changes.
// If it is not possible to merge changes or if a commandline call fails, an error will be returned. */
// func SyncLocalAndRemote(absPathToLocalRepo string) (bool, error) {
// 	hasNoLocalChanges, err := gitStatus.executeExpectedResult(absPathToLocalRepo, nothingToCommit)
// 	if err != nil {
// 		return false, err
// 	}

// 	if hasNoLocalChanges {
// 		return pullMergeLatest(absPathToLocalRepo)
// 	}

// 	err = addCommitChanges(absPathToLocalRepo)
// 	if err != nil {
// 		return false, err
// 	}

// 	_, err = pullMergeLatest(absPathToLocalRepo)
// 	if err != nil {
// 		return false, err
// 	}

// 	return gitPush.executeExpectedResult(absPathToLocalRepo, pushWasSuccessful)
// }

// /* Simply stages everything and creates a combined commit. */
// func addCommitChanges(path string) error {
// 	_, err := gitAddAll.execute(path)
// 	if err != nil {
// 		return err
// 	}

// 	_, err = gitCommit.execute(path)
// 	if err != nil {
// 		return err
// 	}
// 	return nil
// }

// /* Pulls latest and attempts a merge if possible otherwise reverts the merge and returns an error. */
// func pullMergeLatest(path string) (bool, error) {
// 	success, err := gitPullMerge.executeExpectedResult(path, mergeWasSuccessful, allUpToDate)
// 	if err != nil {
// 		return false, err
// 	}

// 	if !success {
// 		_, err = gitAbortMerge.execute(path)
// 		if err != nil {
// 			return false, &MergeFailError{path}
// 		}
// 	}

// 	return true, nil
// }
